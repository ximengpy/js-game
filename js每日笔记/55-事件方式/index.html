<!doctype html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .box{
      position: absolute;
      left: 0;
      top: 0;
      width: 300px;
      height: 300px;
      background-color: red;
    }
  </style>
</head>
<body>
<div class="box"></div>
<script>
  /*
  * 事件: 事情发生了的状态: 需要在什么时候做什么样的事情
  *
  *     的时候
  *
  * 从上往下执行:
  *
  * 交互
  *
  * 事件种类: 点击事件 滚动事件 拖拽事件 鼠标移动事件 键盘事件 请求事件 加载完成事件 窗口大小调整
  * 需要有特定函数处理
  *
  * 以一个事件参考:
  *   1. 事件主体对象( 谁 发生了什么样的事情)
  *   2. 事件类型(涉及很多单词, 尽可能记忆一些单词)
  *   3. 事件处理函数
  *
  *
  * 在点击的时候: click
  *
  * 1. 事件绑定: 处理需求 DOM对象添加onblabla的属性, 拿一个函数处理(赋值给一个函数)
  *     // DOM0级事件
  *
  *     在默认情况下 on事件是没有绑定操作 默认为null 不执行任何操作
  *
  *     直接在标签内部以字符串的形式传入代码的时候, 包裹一个事件
  *     需要手动的写出函数并且执行 才能最终执行
  * 推荐: 通过赋值方式处理
  *
  *
  *
  * 特点:
  *   1. 事件他重复赋值会被覆盖 一个元素同一个事件只能有一个处理函数
  *   2. 普通函数的this this会指向那个元素 箭头函数会绑定上下文
  *   3. 事件对象: 任何事件触发浏览器都会帮我们整理一个事件对象, 储存事件触发的一些细节
  *       是事件处理函数的第一个形参  参数 event e
  *       isTrust  是否是原生事件 浏览器自带的事件
  *       携带很多参数, 比如点击的位置点击, 点击时候其他案件的状态
  *       能获取点击时候的鼠标位置等信息
  *       事件源: e.target 触发事件的那个对象到底是谁
  *   4. 事件绑定取消绑定 直接赋值为null
  * */
  let box = document.querySelector(".box")

  // console.log(box.onclick)

  // function handleClick1(event){
  //   // 修改了点击事件的操作函数, 但是只有在下次点击才会执行
  //   // box.onclick = handleClick2
  //   console.log(event)
  // }
  //
  // box.onclick = handleClick1

  // 谁正在被按下
  // class register{
  //   constructor(options){
  //     this.keydownState = {}
  //     this.init()
  //   }
  //   init(){
  //     window.onkeydown = function (e) {
  //       if(!this.keydownState[e.key.toLowerCase()]){
  //         this.keydownState[e.key.toLowerCase()] = true
  //         console.log("按下", this.keydownState)
  //       }
  //     }
  //     // 抬起键
  //     window.onkeyup = function (e) {
  //       delete this.keydownState[e.key.toLowerCase()]
  //       console.log("抬起", this.keydownState)
  //     }
  //   }
  // }

  // 鼠标按下或者抬起或者双击
  // 分成两个部分的: 按下和抬起

  // window.onclick = function () {
  //   console.log("click")
  // }

  // 想判断
  // window.onmousedown = function (e) {
  //   console.log("按下")
  // }
  // window.onmouseup = function (e) {
  //   console.log("抬起")
  // }

  // 会触发很多次: 做节流, 防抖
  // box.onmousemove = function (e) {
  //   console.log(e)
  // }

  // 鼠标按下 + 鼠标移动 + 鼠标抬起 真实移动盒子

  // 布置一个作业: 尝试做一下 鼠标按下盒子移动盒子跟着动, 鼠标抬起 盒子停下
  // 三步大象思想

  // 组合案件怎么操作?
  // 在一个按键被按下未抬起的时候,再按下另一个按键, 组合操作触发

  // 怎么样保证只触发一次呢?
  // onkeydown的时候判断一下这个按键是否被按下



  // function handleClick2(){
  //   box.onclick = handleClick1
  //   console.log("handleClick2")
  // }

  // 事件绑定代码 通过=号赋值的方式处理
  // 箭头函数this指向会硬绑定上下文的this
  // box.onclick = () => {  handleClick1.call(box)}



  // 第二种事件模型: 事件监听: addEventListener 添加事件监听
  // DOM2级事件
  // 两个参数:
  //    第一个是事件类型
  //        不需要写on 直接写事件名称 以字符串形式传入
  //    第二个是事件处理函数

  /*
  * 事件监听:
  *     1. 新注册了一个函数处理操作, 可以有多个处理函数同时执行, 谁先写谁先执行
  *     2. 事件监听是以函数作为基准, 相同的函数不能重复注册
  *     3. 事件监听的事件对象 和之前的绑定的事件对象 是一致的
  *     4. 事件监听怎么取消: removeEventListener 传和绑定一致的参数
  * */

  // function addEventListener(){
  //   let handleFucList = []
  // }
  // let list = []
  // function handleClick1(e){
  //   console.log(this)
  // }


  // box.onclick = function(e){
  //   list.push(e)
  // }
  //
  // box.addEventListener("click", handleClick1)

  //
  let a = null
  function foo(){
    console.log("click绑定了")
  }
  box.addEventListener("click", function () {
    a = arguments.callee
    console.log("click绑定了")
    box.removeEventListener("click", a)
  })
  // 移出点击事件, 传入的参数一定要和前面的一致

  // 思考一下addEventListener和removeEventListener底层实现
  // 并且自己实现一下
  //

  // 老版本(指IE8以下) => attachEvent / deleteEvent 接受参数是一样的

  // 推荐大家使用事件监听:

  // 循环绑定等操作, 尝试一下用add...系列
  // 看看不同的事件  是怎么触发的以及不同的事件的事件对象是怎么样的

  // 动态生成img的方式怎么获取img的尺寸信息 =>

  // 事件委托.. 如果尽量少的写事件, 通过别的方式观测事件
</script>
</body>
</html>
