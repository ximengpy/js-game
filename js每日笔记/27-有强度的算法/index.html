<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    /*
      递归: 函数内部执行自己
      无穷递归 代码栈溢出的情况

      写递归: 递归的结束判断, 一开始的时候 递归结束的条件表示清楚

      复杂的问题 => 多个简单问题 =>...=> 最简单问题(可以解决的问题, 直接写出答案)

      fn(n) = 1 + 2 + 3 + ... + n

      解决递归问题的时候: 写出转换公式


      考虑已经递归过的答案是否能存下来,如果可以, 请坚决的保存

      fn(n) = n + fn(n - 1)
      ...
      fn(1) = 1

      不是表达式: 指令
      return 1

      f(n) = n + f(n - 1)
      
    */
    /*
      递归: 
        1. 考虑递归结束
        2. 表达式看起来非常清晰易读
        3. 容易理解
    */
    // function fn1(n){
    //   if(n === 1){ 
    //     return 1
    //   }
    //   return n + fn1(n - 1)
    // }

    // /*
    //   for循环: 
    //     1. 控制流程的思想
    //     2. 写起来很复杂
    //     3. 控制不方便
    // */

    // function fn2(n){
    //   // 存储计算结果
    //   let sum = 0
    //   for(let i = 0;i < n;i++){
    //     sum += i + 1
    //   }
    //   return sum
    // }


    // console.log(fn2(10))


    /*
      上楼梯的故事: 
        小银 上楼梯: 一共100台阶
        每次上2层或者3层
        现在站在0层 刚好走到100层的台阶, 请问有多少种走法?

      例子: 台阶 6层
        2 + 2 + 2 一种
        3 + 3     一种
      一共有2种走法
    
      抽象的思想: 

        1. 假设刚好走上n层台阶所有的走法是 fn(n) 种走法

        2. 要走上n层台阶的上一次走法是在哪个位置??
          2.1 从 n-2 往上走一步
          2.2 从 n-3 往上走一步
        
        3. 走上n-2台阶的走法是fn(n-2)
        4. 走上n-3台阶的走法是fn(n-3)

        5. fn(n) = fn(n-2) + fn(n-3)

        在什么时候可以直接解决? 
          fn(2) = 1
          fn(3) = 1

    */

    // function fn(n){
    //   // 从台阶1往上走是不存在的
    //   if(n === 1) return 0
    //   // 从台阶2, 3往上走是只有一种走法
    //   if(n === 2 || n === 3) return 1
    //   return fn(n - 2) + fn(n - 3)
    // }

    // 这是一张答案表, 
    let ansObj = {
      "1": 0,
      "2": 1,
      "3": 1,
    }
    function fn3(n){
      if(n === 1) return ansObj[n]
      // 从台阶2, 3往上走是只有一种走法
      if(n === 2 || n === 3) return ansObj[n]

      // 如果存储器中有答案, 直接抄答案
      if(ansObj[n]) return ansObj[n]
      // 如果没有答案, 咱们先将结果抄到n项中
      ansObj[n] = fn3(n - 2) + fn3(n - 3)
      // 再将答案返回出来
      return ansObj[n]
    }




    // 假如你用for循环: 不可能实现

    /*
      递归所潜在问题: 
        有可能会做很多重复的劳动
    
      例如: 
        O(2^N) >> O(N^3)
        fn(102) = fn(100) + fn(99)
        fn(100) = fn(98) + fn(97)
        fn(98) = fn(96) + fn(95)
        fn(97) = fn(95) + fn(94)

      我已经算过的就不需要算了: 
        已经计算过的结果存储在一个对象中, 
        
        在递归之前先读取对象, 如果对象有值, 就直接返回对象的值
        如果没有值,才计算, 先存储在返回
    */


  </script>
</body>
</html>