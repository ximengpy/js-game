<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
<script>
  /*
  * 对字符串操作
  * 正则表达式:  选择正确的一些条件
  *   描述了一些规则, 让字符串进行匹配
  * */
  // 是一个描述规则的对象 生成对象 RegExp: 正则表达式的构造函数 regular expression
  // 在前端中的表现: 所有的语言都支持这种通用匹配规则 => 其他语言一通百通
  // 产生的原因: 对字符串进行匹配的时候, 一般的函数需要写很多代码, 效率也会很低
  // 例子: str 中有没有出现 0 1 2...9 数字
  // function checkNumber(str){
  //   [].some.call(str, item => {
  //   })
  // }

  // 1. 生成正则表达式
  // RegExp 构造函数生成法 => new
  // new RegExp() 返回一个正则表达式
  // 传两个参数
  // 第一个参数是匹配公式 String
  // 第二个参数 是匹配模式 String
  // 匹配模式: 有且仅有几种
  //    i 忽略大小写

  // let reg1 = new RegExp("a", "i") //
  //
  // // console.log(reg.test("qwer")) // false
  // console.log(reg.test("用正则表达式进行匹配 严银时格识别字符大小写的内容")) // true

  // 第二种写法: 直接写法 直接写出正则表达式:
  //     斜杠的写法: /
  // 以斜杠开始以斜杠结束末尾选择性的添加匹配模式

  // let reg2 = /a/i

  // console.dir(reg1 === reg2)
  // console.dir(reg1)

  // 2. 用正则表达式进行匹配 严格识别字符大小写的内容,
  // 正则表达式对象 .test 方法 测试传入的字符串是否满足表达式匹配条件
  // .exec 迭代匹配
  // .match 符合的匹配
  // 匹配的是整个字符串

  // 是一个对象, 调用这个对象的方法
  // test 测试是否有字符串满足匹配条件

  // 不要觉得我能讲完: 不要觉得你能学懂
  // 面向百度学习: 很多现成的正则表达式: 抄 => 修改


  // 正则表达式的量词: 描述出现过多少次
  // 正则表达式中有一些特殊符号 (特殊含义)

  // 使用反斜杠(\)转义:
  //    一个反斜杠转义反斜杠后面挨着的内容
  //       如果后面的内容是没有别的意义， 那他就不转义
  // {} 中间添加量词
  // () 打包分组
  // [] 同级或者的关系
  // let reg = /aa{2}/
  //
  // let str = "baaa"


  // let str = "{2}sadasd"
  //
  // let reg = /\{2}/
  // console.log(reg.test(str))


  // let str = "\\\\\\" // 这里是一个: \
  //
  // let reg = /\\{3}/ // 这里是匹配  /
  //
  // console.log(reg.test(str))

  // 默认按照贪婪模式来
  // 匹配次数是 0 的时候 直接匹配到空字符串
  // {1,}

  // ** 正则表达式的特殊的符号:

  /*
  * 特殊量词:
  *     特殊符号: * => {0,} 匹配任意次数 优先匹配最多, 可以缩减到0
  *     特殊符号: + => {1,}
  *     特殊符号: ? => {0,1} 匹配任意次数 优先匹配最多, 可以缩减到0
  * */

  /*
  * 正则表达式的中括号: 或者的意思
  * */

  let str1 = "afsdfgih"
  let str2 = "aisd"

  // f或者是i 怎么匹配
  // 要写多少个或者, 就写多少个字符
  // let reg = /[if]/g

  // 匹配所有数字的正则
  // let numReg = /[0123456789]/g
  // let numReg = /[0]/g
  // 字母: 中括号短横线表示字符ascii码的范围内所有的字符都需要参数 或 这种匹配模式
  let reg = /[a-zA-Z0-9]{2}/g
  // 正则表达式已经匹配过了的东西不会回头再去匹配

  // 匹配开始 匹配结束

  // ^ 表示匹配开始  $ 匹配结束 不是匹配某个字符, 匹配某个位置

  // (/^[a-z]{13}$/g)
</script>
</body>
</html>
